import os
import random
import json
import sys
import subprocess
import time
from pathlib import Path
from datetime import datetime, timezone
import pickle
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from pydub import AudioSegment
import requests
from gtts import gTTS

from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from googleapiclient.errors import HttpError

# CONFIG
MEMORY_DIR = "memory/"
OUTPUT_DIR = "videos/"
BG_IMAGES_DIR = "images/"
TOKEN_FILE = "youtube_token.pickle"

for d in [MEMORY_DIR, OUTPUT_DIR, BG_IMAGES_DIR]:
    Path(d).mkdir(exist_ok=True)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MEMORY MANAGEMENT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_used(f):
    p = os.path.join(MEMORY_DIR, f)
    return json.load(open(p, encoding="utf-8")) if os.path.exists(p) else []

def save_used(f, data):
    try:
        json.dump(data, open(os.path.join(MEMORY_DIR, f), "w", encoding="utf-8"),
                  ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"Memory save failed for {f}: {e}")

used_rhymes = load_used("used_rhymes.json")
used_images = load_used("used_images.json")
used_topics = load_used("used_topics.json")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GROQ API (preferred - fast free models)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def groq_request(prompt, model="llama-3.1-8b-instant"):
    try:
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {os.getenv('GROQ_API_KEY')}",
                "Content-Type": "application/json"
            },
            json={
                "model": model,
                "messages": [{"role": "user", "content": prompt}],
                "temperature": 0.95,
                "max_tokens": 500
            },
            timeout=20
        )
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"].strip()
    except Exception as e:
        print(f"Groq error: {e}")
        return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# OPENROUTER FALLBACK (free models)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def openrouter_request(prompt, model="stepfun/step-3.5-flash:free"):
    try:
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {os.getenv('OPENROUTER_API_KEY')}",
                "Content-Type": "application/json"
            },
            json={
                "model": model,
                "messages": [{"role": "user", "content": prompt}],
                "temperature": 0.95,
                "max_tokens": 500
            },
            timeout=30
        )
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"].strip()
    except Exception as e:
        print(f"OpenRouter error: {e}")
        return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SMART TEXT GENERATION (Groq first â†’ OpenRouter fallback)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def smart_generate(prompt):
    result = groq_request(prompt)
    if result:
        print("Generated by Groq")
        return result
    result = openrouter_request(prompt)
    if result:
        print("Generated by OpenRouter fallback")
        return result
    print("Both APIs failed - using fallback")
    return "à¤®à¤œà¥‡à¤¦à¤¾à¤° à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤®\nà¤¬à¤šà¥à¤šà¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¥à¤¯à¤¾à¤°à¤¾ à¤—à¤¾à¤¨à¤¾\nà¤¹à¤à¤¸à¥€-à¤–à¥à¤¶à¥€ à¤¸à¥‡ à¤­à¤° à¤¦à¥‹ à¤¦à¤¿à¤¨\nà¤¦à¥‹à¤¸à¥à¤¤à¥€ à¤•à¤¾ à¤¹à¥ˆ à¤¯à¥‡ à¤œà¤¹à¤¾à¤¨"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GENERATE UNIQUE RHYME
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def gen_rhyme(short=False):
    global used_rhymes
    line_count = 10 if short else 20
    prompt = f"à¤à¤• à¤ªà¥‚à¤°à¥€ à¤¤à¤°à¤¹ à¤¨à¤ˆ, à¤®à¤œà¥‡à¤¦à¤¾à¤° à¤¹à¤¿à¤‚à¤¦à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® à¤¬à¤¨à¤¾à¤“ ({line_count} à¤²à¤¾à¤‡à¤¨à¥‡à¤‚)à¥¤ à¤¤à¥à¤•à¤¬à¤‚à¤¦à¥€ à¤¹à¥‹, à¤¬à¤šà¥à¤šà¥‹à¤‚ à¤•à¥‹ à¤¬à¤¹à¥à¤¤ à¤ªà¤¸à¤‚à¤¦ à¤†à¤, à¤¥à¥€à¤® à¤–à¥à¤¶à¥€, à¤¦à¥‹à¤¸à¥à¤¤à¥€, à¤ªà¥à¤°à¤•à¥ƒà¤¤à¤¿, à¤œà¤¾à¤¨à¤µà¤° à¤¯à¤¾ à¤–à¥‡à¤² à¤•à¤¾ à¤¹à¥‹à¥¤ à¤•à¥‡à¤µà¤² à¤°à¤¾à¤‡à¤® à¤²à¤¿à¤–à¥‹, à¤•à¥‹à¤ˆ à¤…à¤¤à¤¿à¤°à¤¿à¤•à¥à¤¤ à¤Ÿà¤¿à¤ªà¥à¤ªà¤£à¥€ à¤¨à¤¹à¥€à¤‚à¥¤"

    rhyme = smart_generate(prompt)
    if rhyme and rhyme not in used_rhymes:
        used_rhymes.append(rhyme)
        save_used("used_rhymes.json", used_rhymes)
        print("AI-generated unique rhyme:\n", rhyme)
        return rhyme

    fallback = "à¤šà¤‚à¤¦à¤¾ à¤®à¤¾à¤®à¤¾ à¤¦à¥‚à¤° à¤•à¥‡\nà¤ªà¥à¤ à¤ªà¤¾à¤•à¥‡ à¤¬à¥‚à¤° à¤•à¥‡\nà¤¹à¤®à¤•à¥‹ à¤­à¥€ à¤¦à¥‹ à¤¥à¥‹à¤¡à¤¼à¥‡ à¤¸à¥‡\nà¤¹à¤® à¤­à¥€ à¤–à¤¾à¤à¤‚ à¤ªà¥‚à¤°à¥‡ à¤¸à¥‡" * (line_count // 4 + 1)
    if fallback not in used_rhymes:
        used_rhymes.append(fallback)
        save_used("used_rhymes.json", used_rhymes)
    return fallback

def gen_topic(txt):
    global used_topics
    t = " ".join(txt.split()[:5])
    while t in used_topics:
        t += f" {random.choice(['à¤•à¥€ à¤°à¤¾à¤‡à¤®','à¤•à¥€ à¤®à¤¸à¥à¤¤à¥€','à¤•à¤¾ à¤—à¤¾à¤¨à¤¾','à¤¨à¤ˆ à¤µà¤¾à¤²à¥€'])}"
    used_topics.append(t)
    save_used("used_topics.json", used_topics)
    return t

def gen_title(rhyme):
    prompt = f"à¤‡à¤¸ à¤¹à¤¿à¤‚à¤¦à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® à¤•à¥‡ à¤²à¤¿à¤ à¤à¤• à¤µà¤¾à¤¯à¤°à¤² YouTube à¤Ÿà¤¾à¤‡à¤Ÿà¤² à¤¬à¤¨à¤¾à¤“ (à¤‡à¤®à¥‹à¤œà¥€, à¤¨à¤‚à¤¬à¤°, à¤¸à¤µà¤¾à¤², à¤¬à¤šà¥à¤šà¥‹à¤‚ à¤•à¥‹ à¤†à¤•à¤°à¥à¤·à¤¿à¤¤ à¤•à¤°à¤¨à¥‡ à¤µà¤¾à¤²à¤¾): {rhyme[:200]}... à¤•à¥‡à¤µà¤² à¤Ÿà¤¾à¤‡à¤Ÿà¤² à¤²à¤¿à¤–à¥‹à¥¤"
    raw_title = smart_generate(prompt)
    print(f"Raw title: '{raw_title}'")
    cleaned = (raw_title or "").strip()
    if not cleaned or len(cleaned) < 5:
        cleaned = f"à¤ªà¥à¤¯à¤¾à¤°à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® {random.choice(['2026','à¤®à¤¸à¥à¤¤à¥€ à¤µà¤¾à¤²à¥€','à¤–à¥à¤¶à¤¿à¤¯à¥‹à¤‚ à¤¸à¥‡ à¤­à¤°à¥€'])} ğŸ˜"
    print(f"Final title: '{cleaned}'")
    return cleaned

def gen_desc(rhyme):
    prompt = f"à¤‡à¤¸ à¤¹à¤¿à¤‚à¤¦à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® à¤•à¥‡ à¤²à¤¿à¤ à¤à¤• à¤†à¤•à¤°à¥à¤·à¤• YouTube à¤¡à¤¿à¤¸à¥à¤•à¥à¤°à¤¿à¤ªà¥à¤¶à¤¨ à¤¬à¤¨à¤¾à¤“ (100-150 à¤¶à¤¬à¥à¤¦, à¤•à¥€à¤µà¤°à¥à¤¡à¥à¤¸, à¤‡à¤®à¥‹à¤œà¥€, à¤²à¤¾à¤‡à¤•/à¤¸à¤¬à¥à¤¸à¤•à¥à¤°à¤¾à¤‡à¤¬ à¤•à¥‰à¤² à¤Ÿà¥‚ à¤à¤•à¥à¤¶à¤¨ à¤•à¥‡ à¤¸à¤¾à¤¥): {rhyme[:200]}... à¤¡à¤¿à¤¸à¥à¤•à¥à¤°à¤¿à¤ªà¥à¤¶à¤¨ à¤µà¤¾à¤¯à¤°à¤² à¤¹à¥‹à¥¤"
    desc = smart_generate(prompt)
    return desc or f"{rhyme[:120]}...\n#HindiNurseryRhyme #KidsSongs #ViralRhyme"

def gen_hashtags(rhyme):
    prompt = f"à¤‡à¤¸ à¤¹à¤¿à¤‚à¤¦à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® à¤•à¥‡ à¤²à¤¿à¤ 12-15 à¤µà¤¾à¤¯à¤°à¤² YouTube à¤¹à¥ˆà¤¶à¤Ÿà¥ˆà¤— à¤¬à¤¨à¤¾à¤“ (à¤‡à¤®à¥‹à¤œà¥€ à¤•à¥‡ à¤¸à¤¾à¤¥): {rhyme[:100]}..."
    hashtags = smart_generate(prompt)
    return hashtags or "#HindiNurseryRhyme #BacchonKiRhyme #KidsSongs #ViralKids #NurseryRhymes"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DOWNLOAD IMAGE (fallback only - no API needed)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def dl_image(url, path):
    try:
        r = requests.get(url, timeout=20)
        r.raise_for_status()
        with open(path, "wb") as f:
            f.write(r.content)
        print(f"Image downloaded: {path}")
    except:
        os.system(f"curl -o {path} https://picsum.photos/1920/1080")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# THUMBNAIL WITH TEXT (using fallback images)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def create_thumbnail(rhyme, path, short=False):
    # Use random nice placeholder (no API calls needed)
    dl_image("https://picsum.photos/1280/720?random=" + str(random.randint(1,10000)), path)
    try:
        img = Image.open(path)
        draw = ImageDraw.Draw(img)
        font = ImageFont.load_default()
        main_line = rhyme.split('\n')[0][:30] + "..." if len(rhyme.split('\n')[0]) > 30 else rhyme.split('\n')[0]
        bbox = draw.textbbox((0, 0), main_line, font=font)
        text_w = bbox[2] - bbox[0]
        x = (img.width - text_w) // 2
        draw.text((x, img.height - 100), main_line, font=font, fill=(255, 255, 0))
        img.save(path)
        print("Thumbnail with text saved:", path)
    except Exception as e:
        print(f"Thumbnail creation failed: {e}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AUDIO & VIDEO (unchanged - working)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def make_audio(txt, out_mp3):
    try:
        print(f"Generating audio (length {len(txt)} chars)")
        tts = gTTS(txt, lang='hi', tld='co.in')
        tts.save(out_mp3)
        size = os.path.getsize(out_mp3)
        print(f"Audio created, size: {size} bytes")
        if size < 10000:
            raise ValueError("Audio too small")
    except Exception as e:
        print(f"Audio error: {e}")
        sys.exit(1)

def make_video(txt, bg_path, short=False):
    try:
        img = cv2.imread(bg_path)
        if img is None:
            raise ValueError("Background image load failed")

        size = (1080, 1920) if short else (1920, 1080)
        img = cv2.resize(img, size)

        pil_img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        draw = ImageDraw.Draw(pil_img)

        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/noto/NotoSansDevanagari-Regular.ttf", 90 if short else 80)
        except:
            font = ImageFont.load_default()

        lines = txt.split('\n')
        y, dy = 300 if short else 250, 100
        for line in lines:
            bbox = draw.textbbox((0, 0), line, font=font)
            text_w = bbox[2] - bbox[0]
            x = (size[0] - text_w) // 2
            draw.text((x, y), line, font=font, fill=(255, 255, 0))
            y += dy

        img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

        frames = []
        n_frames = 1200
        for i in range(n_frames):
            s = 1 + 0.01 * (i / n_frames)
            h, w = img.shape[:2]
            nh, nw = int(h * s), int(w * s)
            zoomed = cv2.resize(img, (nw, nh))
            crop = zoomed[(nh-h)//2:(nh-h)//2+h, (nw-w)//2:(nw-w)//2+w]
            frames.append(crop)

        tmp_vid = os.path.join(OUTPUT_DIR, "tmp.mp4")
        out = cv2.VideoWriter(tmp_vid, cv2.VideoWriter_fourcc(*'mp4v'), 24, size)
        for f in frames:
            out.write(f)
        out.release()

        intro = "à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤›à¥‹à¤Ÿà¥‡ à¤¦à¥‹à¤¸à¥à¤¤à¥‹à¤‚! à¤†à¤œ à¤¸à¥à¤¨à¥‹ à¤à¤• à¤ªà¥à¤¯à¤¾à¤°à¥€ "
        mid = "à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤®"
        outro = "à¥¤ à¤¬à¤¹à¥à¤¤ à¤ªà¤¸à¤‚à¤¦ à¤†à¤ à¤¤à¥‹ à¤²à¤¾à¤‡à¤•, à¤•à¤®à¥‡à¤‚à¤Ÿ à¤”à¤° à¤¸à¤¬à¥à¤¸à¤•à¥à¤°à¤¾à¤‡à¤¬ à¤•à¤°à¥‹! à¤¬à¥‡à¤² à¤†à¤‡à¤•à¤¨ à¤¦à¤¬à¤¾à¤“!"
        full_text = intro + mid + ":\n\n" + txt + "\n\n" + outro

        aud_path = os.path.join(OUTPUT_DIR, "aud.mp3")
        make_audio(full_text, aud_path)

        final_name = f"rhyme_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4"
        final_path = os.path.join(OUTPUT_DIR, final_name)

        print("Merging video + audio...")
        subprocess.run([
            "ffmpeg", "-y",
            "-i", tmp_vid,
            "-i", aud_path,
            "-c:v", "libx264", "-preset", "slow", "-crf", "22",
            "-c:a", "aac", "-b:a", "192k",
            "-shortest",
            "-pix_fmt", "yuv420p",
            final_path
        ], check=True)

        os.remove(tmp_vid)
        os.remove(aud_path)

        return final_path

    except Exception as e:
        print(f"Video creation failed: {e}")
        sys.exit(1)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# YOUTUBE UPLOAD - SAFE TITLE HANDLING
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def yt_service():
    try:
        creds = None
        if os.path.exists(TOKEN_FILE):
            with open(TOKEN_FILE, 'rb') as f:
                creds = pickle.load(f)

        if creds:
            expiry = creds.expiry
            print(f"Token expiry: {expiry}")

            if expiry is None:
                print("No expiry â€” valid")
            else:
                if expiry.tzinfo is None:
                    expiry = expiry.replace(tzinfo=timezone.utc)
                now_utc = datetime.now(timezone.utc)
                if expiry < now_utc:
                    print("Refreshing token")
                    creds.refresh(Request())
                    with open(TOKEN_FILE, 'wb') as f:
                        pickle.dump(creds, f)
                    print("Token refreshed")
                else:
                    print("Token valid")

        else:
            print("No credentials")
            sys.exit(1)

        return build('youtube', 'v3', credentials=creds)

    except Exception as e:
        print(f"Credential error: {e}")
        sys.exit(1)

def upload(vid, title, desc, tags, short=False, thumbnail_path=None):
    # Final title safety
    title = title.strip()
    if not title or len(title) < 3:
        title = "à¤ªà¥à¤¯à¤¾à¤°à¥€ à¤¨à¤°à¥à¤¸à¤°à¥€ à¤°à¤¾à¤‡à¤® | à¤¬à¤šà¥à¤šà¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤®à¤œà¥‡à¤¦à¤¾à¤° à¤—à¤¾à¤¨à¤¾ ğŸ˜"
        print("Used fallback title")

    max_retries = 5
    for attempt in range(max_retries):
        try:
            yt = yt_service()
            body = {
                'snippet': {'title': title, 'description': desc, 'tags': tags, 'categoryId': '24'},
                'status': {'privacyStatus': 'public'}
            }
            media = MediaFileUpload(vid, mimetype='video/mp4', resumable=True)
            req = yt.videos().insert(part="snippet,status", body=body, media_body=media)
            resp = None
            while resp is None:
                status, resp = req.next_chunk()
                if status:
                    print(f"Upload progress: {int(status.progress()*100)}%")
            vid_id = resp['id']
            print(f"Upload SUCCESS! {'Short' if short else 'Video'} ID: {vid_id}")

            if thumbnail_path:
                yt.thumbnails().set(
                    videoId=vid_id,
                    media_body=MediaFileUpload(thumbnail_path, mimetype='image/png')
                ).execute()
                print("Thumbnail uploaded")

            return vid_id
        except HttpError as e:
            print(f"HTTP error (attempt {attempt+1}): {e}")
            time.sleep(10 * (attempt + 1))
        except Exception as e:
            print(f"Upload error (attempt {attempt+1}): {e}")
            time.sleep(10 * (attempt + 1))
    print("Upload failed after retries.")
    return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MAIN MAGIC
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    print("===== Hindi Kids Nursery Rhymes - Groq + OpenRouter Magic =====")
    success = 0

    try:
        # Long Video
        text_v = gen_rhyme(short=False)
        topic_v = gen_topic(text_v)
        title_v = gen_title(text_v)
        desc_v = gen_desc(text_v)
        tags_v = gen_hashtags(text_v).split()
        thumbnail_path_v = os.path.join(BG_IMAGES_DIR, "thumbnail_long.png")
        create_thumbnail(text_v, thumbnail_path_v, short=False)

        bg_v = os.path.join(BG_IMAGES_DIR, "bg_v.jpg")
        dl_image("https://picsum.photos/1920/1080?random=" + str(random.randint(1,10000)), bg_v)
        video_path = make_video(text_v, bg_v, short=False)

        if upload(video_path, title_v, desc_v, tags_v, thumbnail_path=thumbnail_path_v):
            success += 1

        # Short Video
        text_s = gen_rhyme(short=True)
        topic_s = gen_topic(text_s)
        title_s = gen_title(text_s)
        desc_s = gen_desc(text_s)
        tags_s = gen_hashtags(text_s).split()
        thumbnail_path_s = os.path.join(BG_IMAGES_DIR, "thumbnail_short.png")
        create_thumbnail(text_s, thumbnail_path_s, short=True)

        bg_s = os.path.join(BG_IMAGES_DIR, "bg_s.jpg")
        dl_image("https://picsum.photos/1080/1920?random=" + str(random.randint(1,10000)), bg_s)
        short_path = make_video(text_s, bg_s, short=True)

        if upload(short_path, title_s, desc_s, tags_s, short=True, thumbnail_path=thumbnail_path_s):
            success += 1

        print(f"\n===== Finished! {success}/2 rhymes uploaded =====")

    except Exception as e:
        print(f"CRITICAL ERROR: {e}")
        sys.exit(1)
